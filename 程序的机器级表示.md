# 第三章 程序的机器级表示

## 3.1 历史观点

Intel处理器系列俗称x86，经历了一个长期的、不断进化的发展过程。

**8086**（1978年，29K个晶体管）。它是第一代单芯片、16位微处理器之一。8088是8086的一个变种，在8086上增加了一个8位的外部总线。1980年，Intel提出了8087浮点协处理器（45K个晶体管），它与一个8086或8088处理器一同运行，执行浮点指令。8087建立了x86系列的浮点模型，通常被称为“x87”。

**80286**（1982年，134K个晶体管）。增加了更多的寻址模式（已废弃），构成了IBM PC-AT 个人计算机的基础，这种计算机是MS windows最初的使用平台。

**i386**（1985年，275K个晶体管）。将体系结构拓展到了32位。增加了平坦寻址模式，Linux和最近版本的Windows操作系统都是使用这种模式。这是Intel系列中第一台全面支持Unix操作系统的机器。

**i486**（1989年，1.2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。

**Pentium**（1993年，3.1M个晶体管）。改善了性能，不过只对指令集进行了小的拓展。

**PentiumPro**（1995年，5.5M个晶体管）。引入全新的处理器设计，在内部被称为P6微体系结构。指令集中增加了一类“条件传送”指令。

**Pentium/MMX**（1997年，4.5M个晶体管）。在Pentium处理器中增加了乙类新的处理整数向量的指令。每个数据大小可以是1、2或4字节。每个向量总长64位。

**Pentium II**（1997年，7M个晶体管）。P6为体系结构的延伸。

**Pentium III**（1999年，8.2M个晶体管）。引入了SSE，这是乙类处理整数或浮点数向量的指令。每个数据可以是1、2或4个字节，打包成128位的向量。由于芯片上包括了二级高速缓存，这种芯片后来的版本最多使用了24M个晶体管。

**Pentium 4**（2000年，42M个晶体管）。拓展到了SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的144条新指令。

**Core 2**（2006年，291M个晶体管）。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。

**Core i7 Nehalem**（2008年，781M个晶体管）。即支持超线程，也有多核。

**Core i7 Sandy Bridge**（2011年，1.17G个晶体管）。引入了AVX，这是对SSE的拓展，支持吧数据封装进256位的向量。

**Core i7 Haswell**（2013年，1.4G个晶体管）。将AVX拓展至AVX2，增加了更多的指令和指令格式。

**IA32**，也就是“Intel 32位体系结构（Intel Architecture 32-bit）”，以及最新的Intel64，即IA32的64位拓展，也称为`X86-64`。最常用的名字是“x86”，用以指点整个系列。

## 3.2 程序编码

### 3.2.1 机器级代码

计算机系统使用了多种不同形式的抽象，利用更简单的抽象面模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。

第一种是**由指令集体系结构或指令集架构**（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

第一种抽象是，**机器级程序使用的内存地址是虚拟地址**，提供的内存模型看上去是一个非常大的字节数组。

在整个编译过程中，编译器会完成大部分的工作，将把用C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。

与**机器代码**的二进制格式相比，**汇编代码**的主要特点是它可读性更好的文本格式表示。

x86-64的机器代码和原始的C代码差别非常大，一些通常对C语言程序员隐藏的处理器状态都是可见的：

- **程序计数器**：通常称为PC，在x86-64中用`%rip`表示，它给出将要执行的下一条指令在内存中的地址。
- **整数寄存器文件**：包含16个命令的位置，分别存储64位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- **条件码寄存器**：保存最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如if和while。
- 一组可以存放一个或多个整数或浮点数的**向量寄存器**。

**程序内存**包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。

x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以 一个地址实际上能够指定的是`2^48`或`64TB`范围的字节。

### 3.2.2 代码示例

对于一个C语言源文件mstore.c，包含内容如下：
```c
long mult2(long, long);

void mulstore(long x, long y, long *dest){
  long t = mult2(x, y);
  *dest = t;
}
```
使用`gcc -Og -S mstore.c`，就可以生成对应的汇编代码文件`mstore.s`：
```c
        .file   "mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB0:
        .cfi_startproc
        pushq   %rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE0:
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits

```
上述代码中的每个缩进的不带`.`的指令都表示一条机器指令，比如`pushq    %rbx`表示将寄存器`%rbx`的内容压入程序栈中。

如果使用`-c`命令进行编译，gcc会编译并汇编产生目标文件`mstore.o`，它是二进制格式文件，因此无法直接查看。

`mstore.o`中有一段14字节的序列，它的十六进制表示为：`53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`。这就是上面的汇编指令对应的目标代码。

要查看机器代码文件的内容，有一类称为**反汇编器**（disassembler）的程序很有用，它们根据机器代码可以生成一种类似于汇编代码的格式。在Linux中可以由`objdump -d mstore.o`可以实现得到：
```c
root@linux:~/learn_os/ch2# objdump -d mstore.o

mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq

```
其中一些关于机器代码和它的反汇编表示的特性值得注意：
- x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx是以字节值53开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命令规则与gcc生成的汇编代码使用的有些细微的差别。

生成实际可执行的代码需要对一组目标代码文件运行连接器，而这一组目标代码文件中必须包含有一个main函数。假设在文件main.c中有下面这样的函数：
```c
#include <stdio.h>

void multstore(long, long, long*);

int main(){
  long d;
  multstore(2, 3, &d);
  printf("2 * 3 --> %ld\n", d);
  return 0;
}
long mult2(long a, long b){
  long s = a * b;
  return s;
}
```
然后用`gcc -Og -o prog main.c mstore.c`生成可执行文件`prog`。

文件`prog`的大小约为8.6K字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。

利用`objdump -d prog`对`prog`文件进行反汇编，会得到很长的汇编代码，其中包含如下片段：
```
000000000040061b <multstore>:
  40061b:       53                      push   %rbx
  40061c:       48 89 d3                mov    %rdx,%rbx
  40061f:       e8 ef ff ff ff          callq  400613 <mult2>
  400624:       48 89 03                mov    %rax,(%rbx)
  400627:       5b                      pop    %rbx
  400628:       c3                      retq
  400629:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

```
这段代码与`mstore.c`反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同，因为链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同之处在于链接器填上了callq指令调用函数`mult2`需要使用的地址。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了最后一行，插入这个指令没有什么作用，只是为了使函数代码变为16字节，使得存储器系统能够更好地放置下一个代码块。

**ATT和Intel汇编代码格式**
ATT格式是GCC、OBJDUMP等常用工具的默认格式其他的一些编程工具，如MS的工具，Intel的文档，其汇编代码都是Intel格式的。这两种格式在许多方面有所不同。

利用`gcc -Og -S -masm=intel mstore.c`可以生成Intel格式的汇编代码：
```
        .file   "mstore.c"
        .intel_syntax noprefix
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB0:
        .cfi_startproc
        push    rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        mov     rbx, rdx
        call    mult2
        mov     QWORD PTR [rbx], rax
        pop     rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE0:
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits

```
可以看到Intel和ATT格式在如下方面有所不同：
- Intel代码忽略了指示大小的后缀。如指令`push`和`mov`而不是`pushq`和`movq`。
- Intel代码忽略了寄存器名字前面的`%`符号，用的是`rbx`，而不是`%rbx`。
- Intel代码用不同的方式来描述内存中的位置，例如是`QWORD PTR[rbx]`而不是`(%rbx)`
- 在带有多个操作数的指令情况下，列出操作数的顺序相反。

## 3.3 数据格式

Intel用术语“字（word）”表示16位数据类型。因此称32位数为双字，称64位数为四字。下面给出了C语言基本数据类型对应的x86-64表示：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191008221013988.png" width = "50%">
<div align = left>

如图所示，大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种：`movb`传送字节、`movw`传送字、`movl`传送双字和`movq`传送四字。

## 3.4 访问信息

一个`x86-64`的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。下图显示了这16个寄存器。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191008221656433.png" width = "80%">
<div align = left>

它们的名字都以`%r`开头，不过后面还跟着一些不同的命令规则的名字，这是由于指令集历史演化造成的。最初的8086中有8个16位的寄存器，即图中的`%ax`到`%bp`。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。

拓展到IA32架构时，这些寄存器也拓展成32位寄存器，标号从`%eax`到`ebp`。拓展到x86-64后，原来的8个寄存器拓展成64位，标号从`%rax`到`%rbp`。除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规则指定的：从`%r8`到`%r15`。

如图中嵌套的方框标明的，指令可以对着16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。

在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针`%rsp`，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。

有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

### 3.4.1 操作数指示符

大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种各不同的操作数的可能性被分为三种类型。

第一种类型是**立即数**，用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是`$`后面跟一个用标准C表示的整数，比如，`$-577`或`$0x1F`。不同的指令的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。

第二种类型是**寄存器**，它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或者8字节中的一个作为操作数。

第三种操作数是**内存引用**，它会根据计算出来的地址访问某个内存位置。

下图有多重不同的寻址模式：

<img src = "https://img-blog.csdnimg.cn/20191008223845730.png">

其中，`Imm(rb, ri, s)`表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移`Imm`，几个基址寄存器`rb`，一个变址寄存器`ri`和一个比例因子`s`，这里的`s`必须是1、2、4或者8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为`Imm + R[rb] + R[ri] * s`。

引用数组元素时，会用到这样的通用形式。其形式都是这种通用形式的特殊情况，只是忽略了某些部分。

### 3.4.2 数据传送指令

最频繁使用的指令是将数据从一个位置赋值到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

下图列出了最简单形式的数据传送指令`MOV`类。这些指令把数据从源位置赋值到目的位置，不做任何变化。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191008224224427.png" width = 60%">
<div align = left>

源操作数指定的值是一个立即数，存储在寄存器或者内存中。目的操作数指定一个位置，要么是一个寄存器或者是内存地址。x86-64加了一条限制，传送指令的两个操作数不能同时指向内存地址。将一个值从一个内存位置赋值到另一个内存位置需要两条指令--第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。

这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符('b'\'w'\'l'\'q')指定的大小匹配。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0.

下面的mov指令给出了源和目的类型的五种可能的组合：
```c
  movl $0x4050,%eax       立即数->寄存器，4字节
  movw %bp,%sp            寄存器->寄存器，2字节
  movb (%rdi,%rcx),%al    内存->寄存器，1字节
  movb $-17,(%rsp)        立即数->内存，1字节
  movq $rax,-12(%rbp)     寄存器->内存，8字节
```
`movabsp`指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的；而常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号拓展得到64位的值，放到目的位置。

下图是两类**数据移动指令**，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源复制到目的寄存器。

**movz**类指令为零扩充数据移动指令，该指令把目的中剩余的字节填充为0，而**movs**类指令为符号扩充数据移动指令，把源操作的最高位进行复制。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191009094907949.png" width = "90%">
<div align = left>
  
**理解数据传送如何改变目的寄存器**
```c
    movabsq $0x0011223344556677, %rax     %rax = 0011223344556677
    movb    $-1, %al                      %rax = 00112233445566FF
    movw    $-1, %ax                      %rax = 001122334455FFFF
    movl    $-1, %eax                     %rax = 00000000FFFFFFFF
    movq    $-1, %rax                     %rax = FFFFFFFFFFFFFFFF
```
上述代码中，首先利用`movabsq`将寄存器`%rax`初始化为`0x0011223344556677`。然后利用`movb`将`FF`写入`%rax`的最低一个字节，利用`movw`将`FFFF`覆盖掉`%rax`的最低两个字节，再利用`movl`用`FFFFFFFF`覆盖`%rax`的低四个字节。最后的`movq`将`%rax`全部写为`FFFFFFFFFFFFFFFF`。

上图中还给出了`cltq`指令。这条指令没有操作数，它总是以寄存器`%eax`作为源，`%rax`作为符号扩展结果的目的。它的效果与`movslq %eax, %rax`完全一致，不过变me更紧凑。

### 3.4.3 数据传送示例

考虑下面的数据交换函数：
```c
long exchange(long *xp, long y){
  long x = *xp;
  *xp = y;
  return x;
}
```
```s
exchange:
    movq    (%rdi), %rax
    movq    %rsi, (%rdi)
    ret
```
当过程开始执行时，过程参数`xp`和`y`分别存储在寄存器`%rdi`和`rsi`中。然后，指令2从内存中读出`x`，把它存放到寄存器`%rax`中，即实现了C代码中的`long x = *xp`。然后指令`movq %rsi, (%rdi)`将`y`的值写入到寄存器`%rdi`中的`xp`指向的内存位置，实现了`*xp = y`。`ret`返回时`x`的值正好保存在`%rax`中。

从这段汇编代码中可以看出。首先，C语言中所谓的“指针”起始就是地址。简洁引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用跟这个寄存器。其次，类似`x`这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。

### 3.4.4 压入和弹出栈数据

最后两个数据传送操作可以将数据压入程序栈中，以及虫程序栈中弹出数据，如下图所示：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191009102918188.png" width = "80%">
<div align = left>
  
在x86-64中，程序栈存放在内存中某个区域，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。栈指针`%rsp`保存着栈顶元素的地址。

`pushq`指令的功能是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数。

将一个四字值压入栈中，首先要将栈指针减法8，然后将值写到新的栈顶地址。因此指令`pushq %rbp`的行为等价于下面两条指令：
```s
  subq $8, %rsp
  movq %rbp, (%rsp)
```
它们之间的区别在于机器代码中`pushq`指令编码为1个字节，而上面两条指令一共需要8个字节。

因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令`movq 8(%rsp), %rdx`会将第二个四字从栈中复制到寄存器`%rdx`。

## 3.5 算数和逻辑操作

下图列出了x86-64的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有leaq没有其他大小的变种）。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191009105004833.png" width = "60%">
<div align = left>
  
### 3.5.1 加载有效地址

**加载有效地址**指令`leaq`实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的的操作数。

另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器`%rdx`的值为`x`，那么指令`leaq 7(%rdx, %rdx, 4), %rax`将设置寄存器`%rax`的值为`5x + 7`。

对于下面C程序：
```c
long scale(long x, long y, long z){
  long t = x + 4 * y + 12 * z;
  return t;
}
```
```s
scale:
  leaq    (%rdi, %rsi, 4), %rax           x + 4*y
  leaq    (%rdx, %rdx, 2), %rdx           z + 2*z = 2*z
  leaq    (%rax, %rdx, 4), %rax           (x+4*y) + 4*(3*z) = x + 4*y + 12*z
  ret
```

### 3.5.2 一元和二元操作

第二组中的操作是一元操作，只要一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。比如说，指令incq(%rsp)会使栈顶的8字节元素加1。

第三组是二元操作，其中，第二个操作数既是源又是目的。例如，指令`subq %rax, %rdx`使寄存器`%rdx`的值减去`%rax`。第一个操作数可以是立即数、寄存器或内存位置。第二个操作室可以是寄存器或内存位置。

### 3.5.3 移位操作

最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算数和逻辑右移。

移位量可以是一个立即数，或者放在单字节寄存器`%c1`中。

x86-64中，移位操作对w位长的数据值进行操作，移位量是由`%c1`寄存器的低m位决定的，这里`2^m=w`。高位会被忽略。所以，当寄存器`%c1`的十六进制值为`0xff`时，指令`salb`会移7位，`salw`会移15位，`sall`会移31位，而`salq`会移63位。

移位操作的目的操作数可以是一个寄存器或是一个内存位置。

```c
long shift_left4_rightn(long x, long n){
  x <<= 4;
  x >>= n;
  return x;
}
```
```
shift_left4_rightn:
    movq    %rdi, %rax
    salq    $4, %rax
    movl    %esi, %ecx
    sarq    %cl, %rax
    ret
```

### 3.5.5 特殊的算术操作

两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。x86-64指令集对128位数的操作提供有限的支持。

Intel把16字节的数称为八字（oct word）。下图描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191009114701239.png" width = "90%">
<div align = left>
  
 
