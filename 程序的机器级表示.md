# 第三章 程序的机器级表示

## 3.1 历史观点

Intel处理器系列俗称x86，经历了一个长期的、不断进化的发展过程。

**8086**（1978年，29K个晶体管）。它是第一代单芯片、16位微处理器之一。8088是8086的一个变种，在8086上增加了一个8位的外部总线。1980年，Intel提出了8087浮点协处理器（45K个晶体管），它与一个8086或8088处理器一同运行，执行浮点指令。8087建立了x86系列的浮点模型，通常被称为“x87”。

**80286**（1982年，134K个晶体管）。增加了更多的寻址模式（已废弃），构成了IBM PC-AT 个人计算机的基础，这种计算机是MS windows最初的使用平台。

**i386**（1985年，275K个晶体管）。将体系结构拓展到了32位。增加了平坦寻址模式，Linux和最近版本的Windows操作系统都是使用这种模式。这是Intel系列中第一台全面支持Unix操作系统的机器。

**i486**（1989年，1.2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。

**Pentium**（1993年，3.1M个晶体管）。改善了性能，不过只对指令集进行了小的拓展。

**PentiumPro**（1995年，5.5M个晶体管）。引入全新的处理器设计，在内部被称为P6微体系结构。指令集中增加了一类“条件传送”指令。

**Pentium/MMX**（1997年，4.5M个晶体管）。在Pentium处理器中增加了乙类新的处理整数向量的指令。每个数据大小可以是1、2或4字节。每个向量总长64位。

**Pentium II**（1997年，7M个晶体管）。P6为体系结构的延伸。

**Pentium III**（1999年，8.2M个晶体管）。引入了SSE，这是乙类处理整数或浮点数向量的指令。每个数据可以是1、2或4个字节，打包成128位的向量。由于芯片上包括了二级高速缓存，这种芯片后来的版本最多使用了24M个晶体管。

**Pentium 4**（2000年，42M个晶体管）。拓展到了SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的144条新指令。

**Core 2**（2006年，291M个晶体管）。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。

**Core i7 Nehalem**（2008年，781M个晶体管）。即支持超线程，也有多核。

**Core i7 Sandy Bridge**（2011年，1.17G个晶体管）。引入了AVX，这是对SSE的拓展，支持吧数据封装进256位的向量。

**Core i7 Haswell**（2013年，1.4G个晶体管）。将AVX拓展至AVX2，增加了更多的指令和指令格式。

**IA32**，也就是“Intel 32位体系结构（Intel Architecture 32-bit）”，以及最新的Intel64，即IA32的64位拓展，也称为`X86-64`。最常用的名字是“x86”，用以指点整个系列。

## 3.2 程序编码

### 3.2.1 机器级代码

计算机系统使用了多种不同形式的抽象，利用更简单的抽象面模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。

第一种是**由指令集体系结构或指令集架构**（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

第一种抽象是，**机器级程序使用的内存地址是虚拟地址**，提供的内存模型看上去是一个非常大的字节数组。

在整个编译过程中，编译器会完成大部分的工作，将把用C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。

与**机器代码**的二进制格式相比，**汇编代码**的主要特点是它可读性更好的文本格式表示。

x86-64的机器代码和原始的C代码差别非常大，一些通常对C语言程序员隐藏的处理器状态都是可见的：

- **程序计数器**：通常称为PC，在x86-64中用`%rip`表示，它给出将要执行的下一条指令在内存中的地址。
- **整数寄存器文件**：包含16个命令的位置，分别存储64位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- **条件码寄存器**：保存最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如if和while。
- 一组可以存放一个或多个整数或浮点数的**向量寄存器**。

**程序内存**包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。

x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以 一个地址实际上能够指定的是`2^48`或`64TB`范围的字节。

### 3.2.2 代码示例

对于一个C语言源文件mstore.c，包含内容如下：
```c
long mult2(long, long);

void mulstore(long x, long y, long *dest){
  long t = mult2(x, y);
  *dest = t;
}
```
使用`gcc -Og -S mstore.c`，就可以生成对应的汇编代码文件`mstore.s`：
```c
        .file   "mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB0:
        .cfi_startproc
        pushq   %rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE0:
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits

```
上述代码中的每个缩进的不带`.`的指令都表示一条机器指令，比如`pushq    %rbx`表示将寄存器`%rbx`的内容压入程序栈中。

如果使用`-c`命令进行编译，gcc会编译并汇编产生目标文件`mstore.o`，它是二进制格式文件，因此无法直接查看。

`mstore.o`中有一段14字节的序列，它的十六进制表示为：`53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`。这就是上面的汇编指令对应的目标代码。

要查看机器代码文件的内容，有一类称为**反汇编器**（disassembler）的程序很有用，它们根据机器代码可以生成一种类似于汇编代码的格式。在Linux中可以由`objdump -d mstore.o`可以实现得到：
```c
root@linux:~/learn_os/ch2# objdump -d mstore.o

mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq

```
其中一些关于机器代码和它的反汇编表示的特性值得注意：
- x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx是以字节值53开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命令规则与gcc生成的汇编代码使用的有些细微的差别。

生成实际可执行的代码需要对一组目标代码文件运行连接器，而这一组目标代码文件中必须包含有一个main函数。假设在文件main.c中有下面这样的函数：
```c
#include <stdio.h>

void multstore(long, long, long*);

int main(){
  long d;
  multstore(2, 3, &d);
  printf("2 * 3 --> %ld\n", d);
  return 0;
}
long mult2(long a, long b){
  long s = a * b;
  return s;
}
```
然后用`gcc -Og -o prog main.c mstore.c`生成可执行文件`prog`。

文件`prog`的大小约为8.6K字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。

利用`objdump -d prog`对`prog`文件进行反汇编，会得到很长的汇编代码，其中包含如下片段：
```
000000000040061b <multstore>:
  40061b:       53                      push   %rbx
  40061c:       48 89 d3                mov    %rdx,%rbx
  40061f:       e8 ef ff ff ff          callq  400613 <mult2>
  400624:       48 89 03                mov    %rax,(%rbx)
  400627:       5b                      pop    %rbx
  400628:       c3                      retq
  400629:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

```
这段代码与`mstore.c`反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同，因为链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同之处在于链接器填上了callq指令调用函数`mult2`需要使用的地址。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了最后一行，插入这个指令没有什么作用，只是为了使函数代码变为16字节，使得存储器系统能够更好地放置下一个代码块。

**ATT和Intel汇编代码格式**
ATT格式是GCC、OBJDUMP等常用工具的默认格式其他的一些编程工具，如MS的工具，Intel的文档，其汇编代码都是Intel格式的。这两种格式在许多方面有所不同。

利用`gcc -Og -S -masm=intel mstore.c`可以生成Intel格式的汇编代码：
```
        .file   "mstore.c"
        .intel_syntax noprefix
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB0:
        .cfi_startproc
        push    rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        mov     rbx, rdx
        call    mult2
        mov     QWORD PTR [rbx], rax
        pop     rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE0:
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits

```
可以看到Intel和ATT格式在如下方面有所不同：
- Intel代码忽略了指示大小的后缀。如指令`push`和`mov`而不是`pushq`和`movq`。
- Intel代码忽略了寄存器名字前面的`%`符号，用的是`rbx`，而不是`%rbx`。
- Intel代码用不同的方式来描述内存中的位置，例如是`QWORD PTR[rbx]`而不是`(%rbx)`
- 在带有多个操作数的指令情况下，列出操作数的顺序相反。

## 3.3 数据格式

Intel用术语“字（word）”表示16位数据类型。因此称32位数为双字，称64位数为四字。下面给出了C语言基本数据类型对应的x86-64表示：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20191008221013988.png" width = "50%">
<div align = left>

如图所示，大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种：`movb`传送字节、`movw`传送字、`movl`传送双字和`movq`传送四字。

## 3.4 访问信息

一个`x86-64`

